# cli_validate_pine_lock3_v1_1_6.py — Hardened .pine.lock+++ Validator (v1.1.6) # Deltas vs v1.1.5: # - Tri-state MAC status: VERIFIED | FAILED | SKIPPED # - SUPPORTED_VERSIONS list (forward-compat) # - Unified warning system with tags + verbosity gating (+ optional --show-mapping-gaps) # - Grouped, tagged diagnostics with [DIAG] headers # - Meta-validation for EXPECT_FWD / EXPECT_REV parity # - --fail-on-warn enhanced: --warn-threshold, --ignore-warn-tags # - Selective detector control: --skip-detectors (by rule id or label), --only-detectors # - Strict bool enforcement on detectors without implicit cast # - Refactor minor utilities (unique list check), logging-like output via a single emit() import json, re, sys, argparse, datetime, hmac, hashlib from enum import Enum # ===== Optional schema support ===== try: from jsonschema import validate as schema_validate HAVE_JSONSCHEMA = True except: HAVE_JSONSCHEMA = False # ===== Constants ===== LOCK_MIN_SCHEMA = { "type":"object", "required":["schema_version","version","pre_hash","post_hash","mac","last_verified"], "properties":{ "schema_version":{"type":"string"}, "version":{"type":"string"}, "pre_hash":{"type":"string"}, "post_hash":{"type":"string"}, "mac":{"type":"string"}, "last_verified":{"type":"string"} } } SUPPORTED_VERSIONS = ["v6","v7"] # future-friendly HEX64 = re.compile(r"^[A-Fa-f0-9]{64}$") RULE_ID = re.compile(r"^O\d{1,2}(?:\.[A-Za-z0-9_]+)*$") ISOZ = "%Y-%m-%dT%H:%M:%SZ" DEF_PRIORITY = ["Persona","Outcome","Security","Signatures","Scope","Type","Quotas","Visual"] class Mode(Enum): STRICT = "strict" AUDIT = "audit" DEV = "dev" class Verb(Enum): QUIET = 0 NORMAL = 1 VERBOSE = 2 # ===== Forward + reverse expectations ===== def fwd_drift_flag(lock): d=lock.get("drift",{}) return bool(isinstance(d,dict) and d.get("flag",False)) def fwd_collapse_used(lock): k=lock.get("kpis",{}) return bool(isinstance(k,dict) and k.get("collapse_used")) def fwd_intent_outcome(lock): v=lock.get("intent",{}).get("outcome") return v in ("aligned","mismatch","unknown") and v!="aligned" def fwd_alert_cohesion_flag(lock): ac=lock.get("alert_cohesion",{}) return any(bool(v.get("cohesion_flag")) for v in ac.values()) if isinstance(ac,dict) else False # label -> (required_rule_id, detector_fn) EXPECT_FWD = { "drift.flag" : ("O31", fwd_drift_flag), "kpis.collapse_used" : ("O40", fwd_collapse_used), "intent.outcome!=aligned" : ("O24", fwd_intent_outcome), "alert_cohesion.*.cohesion_flag" : ("O44", fwd_alert_cohesion_flag), } # rule id (specific) or family root -> checker(lock) → bool EXPECT_REV = { "O99": lambda lock: bool(lock.get("overrides")), "O40": lambda lock: bool(lock.get("kpis",{}).get("collapse_used")) or bool(lock.get("collapse_map")), "O24": lambda lock: lock.get("intent",{}).get("outcome") in ("aligned","mismatch","unknown"), "O44": lambda lock: bool(lock.get("alert_cohesion")), "O31": lambda lock: "drift" in lock, # Example specific id: # "O44.direct": lambda lock: any(v.get("type")=="direct" for v in lock.get("latency_map",{}).values()), } # ===== Global state ===== WARNINGS = [] # list of (tag, message) VERBOSITY = Verb.NORMAL STRICT_MAPPING = False DETECTOR_STRICT = True SHOW_MAPPING_GAPS = False MAC_STATE = "SKIPPED" # VERIFIED | FAILED | SKIPPED # ===== Emit / warn ===== def emit(level, msg, tag=None): """level: 'INFO','WARN','FAIL','DIAG'""" if level == "WARN": WARNINGS.append((tag or "GEN", msg)) print(f"WARN[{tag or 'GEN'}]: {msg}") elif level == "INFO": print(f"INFO: {msg}") elif level == "FAIL": print(f"FAIL: {msg}") elif level == "DIAG": print(f"[DIAG] {msg}") else: print(msg) def diag_header(title): if VERBOSITY.value >= Verb.VERBOSE.value: emit("DIAG", f"== {title} ==") def vwarn(level_needed, tag, msg, force_show=False): if force_show and SHOW_MAPPING_GAPS: emit("WARN", msg, tag=tag); return if VERBOSITY.value >= level_needed: emit("WARN", msg, tag=tag) def warn(tag, msg): emit("WARN", msg, tag=tag) # ===== Utils ===== def is_iso8601_z(x): try: datetime.datetime.strptime(x, ISOZ); return True except: return False def is_hex64(x): return isinstance(x,str) and bool(HEX64.match(x)) def now_utc(): return datetime.datetime.utcnow() def check_unique_list(name, lst): seen=set() for x in lst: if x in seen: return False seen.add(x) return True def must(cond, msg, level="error", *, mode:Mode, warn_only=False, ignore_integrity=False, tag="GEN"): if cond: return if level=="integrity": if ignore_integrity and mode==Mode.DEV: emit("WARN", f"IGNORED INTEGRITY: {msg}", tag="INTEGRITY") return raise SystemExit(f"FAIL[INTEGRITY]: {msg}") if level=="warn" or warn_only or mode in (Mode.AUDIT, Mode.DEV): emit("WARN", msg, tag=tag) else: raise SystemExit(f"FAIL: {msg}") def mac_payload(lock): return f"{lock['post_hash']}|{','.join(lock.get('rules_fired',[]))}|{lock['persona_learned']}|{lock['last_verified']}" def verify_mac(lock, *, simulate, test_salt, ignore_integrity, mode:Mode): global MAC_STATE for k in ["post_hash","rules_fired","persona_learned","last_verified","mac"]: must(k in lock, f"MAC payload missing field: {k}", level="integrity", mode=mode, ignore_integrity=ignore_integrity, tag="INTEGRITY") must(is_hex64(lock["mac"]), "mac must be 64-hex", level="integrity", mode=mode, ignore_integrity=ignore_integrity, tag="INTEGRITY") payload = mac_payload(lock).encode("utf-8") if simulate: salt_bytes = (test_salt.encode("utf-8") if isinstance(test_salt,str) else test_salt) or b"DEAD_BEEF_TEST_SALT" expected = hmac.new(salt_bytes, payload, hashlib.sha256).hexdigest() print(f"DEBUG: expected_mac={expected}") print(f"DEBUG: provided_mac={lock['mac'].lower()}") if expected == lock["mac"].lower(): MAC_STATE = "VERIFIED" else: MAC_STATE = "FAILED" must(False, "simulated HMAC mismatch; use --test-salt or --ignore-integrity in dev", level="integrity", mode=mode, ignore_integrity=ignore_integrity, tag="INTEGRITY") else: MAC_STATE = "SKIPPED" if VERBOSITY==Verb.VERBOSE: emit("INFO", "MAC verification skipped; run with --simulate-mac for test HMAC.") def compat_get(lock, key, *, compat_mode, msg, mode:Mode, warn_only, ignore_integrity, tag="GEN"): present = key in lock if not present and compat_mode=="tolerant": must(False, f"Missing optional key: {key}", level="warn", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity, tag=tag) return None, False must(present, msg, mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity, tag=tag) return lock[key], True def metavalidate_expectations(): """Meta-consistency for EXPECT_FWD/EXPECT_REV.""" # ensure FWD -> REV root or exact id exists missing=[] for label,(rid,det) in EXPECT_FWD.items(): if not callable(det): missing.append(f"{label}: detector not callable") root = rid.split(".")[0] if root not in EXPECT_REV and rid not in EXPECT_REV: missing.append(f"{label} -> {rid} missing reverse checker") if missing: msg = " ; ".join(missing) if STRICT_MAPPING: raise SystemExit(f"FAIL[MAPPING]: {msg}") vwarn(1,"MAP", msg, force_show=True) # advise REV entries without FWD fwd_roots = {rid.split(".")[0] for (rid, _) in EXPECT_FWD.values()} extras = [r for r in EXPECT_REV.keys() if (r not in fwd_roots and r not in EXPECT_FWD)] if extras: vwarn(2, "MAP", f"EXPECT_FWD has no forward mapping for reverse rules: {', '.join(extras)}", force_show=True) def validate(lock, *, mode:Mode, warn_only, compat_arg, ignore_integrity, schema_path, simulate_mac, test_salt, fail_on_warn, warn_threshold, ignore_warn_tags, skip_detectors, only_detectors): # integrity ignore gate if ignore_integrity and mode!=Mode.DEV: raise SystemExit("FAIL: --ignore-integrity is allowed only with --mode=dev") # Meta-validation of expectations diag_header("Mapping Diagnostics") metavalidate_expectations() # $schema handling declared_schema = lock.get("$schema") if declared_schema and not schema_path: if HAVE_JSONSCHEMA: vwarn(1, "SCHEMA", f"$schema declared ({declared_schema}) but no --schema provided; using minimal embedded schema", force_show=True) else: vwarn(1, "SCHEMA", f"$schema declared ({declared_schema}) but jsonschema not installed; install jsonschema or provide --schema", force_show=True) # JSON Schema validation if schema_path: if not HAVE_JSONSCHEMA: raise SystemExit("FAIL: jsonschema not installed; cannot use --schema") try: with open(schema_path,"r",encoding="utf-8") as sf: schema = json.load(sf) schema_validate(instance=lock, schema=schema) emit("INFO","External schema validation: PASS") except Exception as e: raise SystemExit(f"FAIL: External schema validation failed: {e}") else: if HAVE_JSONSCHEMA: try: schema_validate(instance=lock, schema=LOCK_MIN_SCHEMA) emit("INFO","Minimal schema validation: PASS") except Exception as e: vwarn(1, "SCHEMA", f"Minimal schema validation failed: {e}", force_show=True) compat_mode = lock.get("compat_mode","strict") if compat_arg: compat_mode = compat_arg must(compat_mode in ("strict","tolerant"), "compat_mode must be strict|tolerant", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) sv,_ = compat_get(lock,"schema_version", compat_mode=compat_mode, msg="schema_version missing", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(sv in ("1.1.6","1.1.5","1.1.4","1.1.3","1.1.2","1.1.1","1.1.0","1.0.0"), "unsupported schema_version", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) ver,_= compat_get(lock,"version", compat_mode=compat_mode, msg="version missing", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(ver in SUPPORTED_VERSIONS, f"version must be one of {SUPPORTED_VERSIONS}", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) # Persona pc = lock.get("persona_claimed"); pl = lock.get("persona_learned") spm = lock.get("strict_persona_match", False) ranks={"Casual":0,"Dev":1,"Quant":2,"Casual+":0,"Dev+":1,"Quant+":2} must(pc in ("Casual","Dev","Quant"), "persona_claimed invalid", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(pl in ("Casual+","Dev+","Quant+"), "persona_learned invalid", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(isinstance(spm,bool),"strict_persona_match must be bool", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) if spm: must(ranks[pc] >= ranks[pl], "strict_persona_match violated (claimed < learned)", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) else: if ranks[pc] < ranks[pl]: vwarn(1, "MAP", "claimed persona lower than learned; consider upgrade or enable strict match", force_show=True) # Integrity fields + MAC must(is_hex64(lock.get("pre_hash","")) and is_hex64(lock.get("post_hash","")), "pre_hash/post_hash must be 64-hex", level="integrity", mode=mode, ignore_integrity=ignore_integrity, tag="INTEGRITY") must(lock.get("lock_status") in ("verified","regenerated"), "lock_status invalid", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(is_iso8601_z(lock.get("last_verified","")), "last_verified must be ISO8601 Z", level="integrity", mode=mode, ignore_integrity=ignore_integrity, tag="INTEGRITY") verify_mac(lock, simulate=simulate_mac, test_salt=test_salt, ignore_integrity=ignore_integrity, mode=mode) # Rules fired rf = lock.get("rules_fired",[]) must(isinstance(rf,list), "rules_fired must be list", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) for r in rf: must(bool(RULE_ID.match(r)), f"rules_fired id invalid: {r}", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(check_unique_list("rules_fired", rf), "rules_fired contains duplicates", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) # Reverse checks diag_header("Reverse Rule Checks") for r in rf: checker = EXPECT_REV.get(r) or EXPECT_REV.get(r.split(".")[0]) if checker: try: ok = checker(lock) must(isinstance(ok,bool), f"EXPECT_REV[{r}] checker did not return bool", mode=mode, warn_only=False, ignore_integrity=ignore_integrity, tag="REV") except Exception as e: must(False, f"EXPECT_REV[{r}] checker raised: {e}", mode=mode, warn_only=False, ignore_integrity=ignore_integrity, tag="REV") if not ok: vwarn(1, "REV", f"Rule {r} fired but no matching content found (stale/inert rule?)", force_show=True) else: vwarn(2, "MAP", f"No reverse checker for rule {r} (EXPECT_REV gap)", force_show=True) # Conflicts for c in lock.get("conflicts",[]): for req in ("span","contenders","winner","suppressed","reason"): must(req in c, f"conflict missing {req}", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(len(c["contenders"])>=1, "conflict.contenders empty", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) # Priority ladder if "rule_priority_ladder" in lock: must(lock["rule_priority_ladder"]==DEF_PRIORITY, "rule_priority_ladder mismatch", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) else: if lock.get("compat_mode","strict")=="tolerant": vwarn(1, "MAP", "rule_priority_ladder missing (tolerant mode)", force_show=True) else: must(False, "rule_priority_ladder missing (strict mode)", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) # Parity hashes for k in ("signal_hash","object_hash","alert_hash"): must(is_hex64(lock.get("parity",{}).get(k,"")), f"parity.{k} hex", level="integrity", mode=mode, ignore_integrity=ignore_integrity, tag="INTEGRITY") # Intent io = lock.get("intent",{}) must(io.get("outcome") in ("aligned","mismatch","unknown"), "intent.outcome enum", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) if io.get("outcome")=="mismatch": has_ov = any(True for _ in lock.get("overrides",[])) if mode==Mode.STRICT: must(has_ov, "intent.outcome==mismatch requires override (strict)", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) else: vwarn(1, "MAP", "intent.outcome mismatch without override", force_show=True) # Drift dr = lock.get("drift",{}) for vv in ("d14_hash","d30_hash"): must(is_hex64(dr.get(vv,"")), f"drift.{vv} hex", level="integrity", mode=mode, ignore_integrity=ignore_integrity, tag="INTEGRITY") must(dr.get("d14_volatility") in ("normal","shock","illiquid"), "d14_volatility enum", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(dr.get("d30_volatility") in ("normal","shock","illiquid"), "d30_volatility enum", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(dr.get("script_sensitivity_profile") in ("passive","reactive","aggressive"), "script_sensitivity_profile enum", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(dr.get("drift_risk") in ("low","medium","high"), "drift_risk enum", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(isinstance(dr.get("flag",None), bool), "drift.flag bool", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(dr["flag"] == (dr["drift_risk"]=="high"), "drift.flag must equal (drift_risk=='high')", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) # Timelines tl = lock.get("timelines",{}) for grp in ("signals","alerts"): for k, arr in tl.get(grp,{}).items(): must(all(isinstance(i,int) and i>=0 for i in arr), f"timelines.{grp}.{k} nonneg ints", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) # Latency + cohesion for aid, v in lock.get("latency_map",{}).items(): must(v.get("type") in ("direct","compound"), f"latency_map[{aid}].type enum", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(v.get("avg_bars",0)>=0 and v.get("p95_bars",0)>=0, f"latency_map[{aid}] nonneg", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) if v["type"]=="direct" and v.get("avg_bars",0)>1: must("overrides" in lock, "direct alert avg_bars>1 needs override", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) for aid, v in lock.get("alert_cohesion",{}).items(): must(0<=v.get("in_exposure_ratio",0)<=1, f"alert_cohesion[{aid}].ratio in [0,1]", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(isinstance(v.get("cohesion_flag",False),bool), f"alert_cohesion[{aid}].flag bool", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) # KPIs + collapse kpis = lock.get("kpis",{}) must(kpis.get("avg_passes_to_zero",0)>=0, "avg_passes_to_zero >=0", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) cm = lock.get("collapse_map",{}) if kpis.get("collapse_used"): must(len(cm)>=1, "collapse_map required when collapse_used", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) if cm: for cid in cm.keys(): if not any(cid in r for r in rf): vwarn(1, "ORPHAN", f"collapse_map id '{cid}' never referenced in rules_fired", force_show=True) for mid, meta in cm.items(): must("source_fix_ids" in meta and len(meta["source_fix_ids"])>=1, "collapse source_fix_ids missing", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) if "n_collapsed" in meta: must(meta["n_collapsed"]>=1, "n_collapsed>=1", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) if "diff_size" in meta: must(meta["diff_size"] >=1, "diff_size>=1", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) # Struct + semantic governor st = lock.get("struct",{}) must(is_hex64(st.get("Hstruct","")) and is_hex64(st.get("Hsem","")), "Hstruct/Hsem hex", level="integrity", mode=mode, ignore_integrity=ignore_integrity, tag="INTEGRITY") vm = st.get("verbosity_mode","standard") must(vm in ("minimal","standard","deep"), "verbosity_mode enum", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) sem_ok = st.get("semantic_ok",False); sem_cnt = st.get("semantic_ok_count",0) must(isinstance(sem_ok,bool) and isinstance(sem_cnt,int), "semantic_ok/count types", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) if sem_ok and sem_cnt>2 and mode!=Mode.DEV: must(False, "OVERRIDE.LOOP: semantic_ok_count>2", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) if "graph_diff_report" not in st and lock.get("compat_mode","strict")=="tolerant": vwarn(1, "MAP", "graph_diff_report missing (tolerant)", force_show=True) # Overrides for ov in lock.get("overrides",[]): scope = ov.get("scope") must(scope in ("session","persistent","defer_review"), "override.scope enum", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(isinstance(ov.get("reason",""),str) and ov["reason"], "override reason required", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity) must(is_iso8601_z(ov.get("ts","")), "override ts ISO8601Z", level="integrity", mode=mode, ignore_integrity=ignore_integrity, tag="INTEGRITY") if scope=="persistent" and "expiry" in ov: try: expiry = datetime.datetime.strptime(ov["expiry"], ISOZ) if expiry < now_utc(): lvl = "warn" if mode!=Mode.STRICT else "error" must(False, f"Override expired: {ov.get('rule','?')}", level=lvl, mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity, tag="GEN") except: must(False, "override.expiry invalid ISO8601Z", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity, tag="GEN") if lock.get("lock_status")=="regenerated": reason = lock.get("revalidation_reason") must(reason in ("mac_invalid","hash_mismatch","manual_reset"), "revalidation_reason required for regenerated", mode=mode, warn_only=warn_only, ignore_integrity=ignore_integrity, tag="GEN") vwarn(1, "GEN", "Post-regeneration engine revalidation cannot be proven by static validator", force_show=True) # Forward expectations with selection controls diag_header("Forward Expectation Checks") for label, (rid, detector) in EXPECT_FWD.items(): # selection filters if only_detectors and (rid not in only_detectors and label not in only_detectors): continue if skip_detectors and (rid in skip_detectors or label in skip_detectors): continue try: fired = detector(lock) must(isinstance(fired,bool), f"EXPECT_FWD[{label}] detector must return bool", mode=mode, warn_only=False, ignore_integrity=ignore_integrity, tag="FWD") except Exception as e: if DETECTOR_STRICT: must(False, f"EXPECT_FWD[{label}] detector raised: {e}", mode=mode, warn_only=False, ignore_integrity=ignore_integrity, tag="FWD") else: vwarn(1, "FWD", f"Detector error for {label}: {e}", force_show=True) fired = False if fired and rid not in rf: vwarn(1, "FWD", f"{label} active but {rid} not in rules_fired", force_show=True) # ===== Summary + escalation ===== status = "WARN" if len(WARNINGS)>0 else "PASS" print(f"\n✅ VALIDATION COMPLETE — MODE: {mode.value.upper()} — STATUS: {status} — MAC: {MAC_STATE}\n") if WARNINGS: # optional summary by tag counts={} for t,_m in WARNINGS: counts[t]=counts.get(t,0)+1 summary = ", ".join([f"{k}:{v}" for k,v in sorted(counts.items())]) print(f"⚠️ {len(WARNINGS)} warning(s): {summary}") # apply ignore tags + threshold eff = [w for w in WARNINGS if w[0] not in ignore_warn_tags] if fail_on_warn and (len(eff) > (warn_threshold if warn_threshold is not None else 0)): raise SystemExit("FAIL: warnings exceeded threshold with --fail-on-warn") def main(): ap = argparse.ArgumentParser(description=".pine.lock+++ hardened validator v1.1.6") ap.add_argument("path", help="path to .pine.lock+++.json") ap.add_argument("--mode", choices=[m.value for m in Mode], default="strict") ap.add_argument("--warn-only", action="store_true", help="downgrade non-integrity failures to warnings") ap.add_argument("--ignore-integrity", action="store_true", help="DEV ONLY: ignore integrity failures (MAC/hash/time)") ap.add_argument("--compat", choices=["strict","tolerant"], help="override lock.compat_mode") ap.add_argument("--schema", help="external JSON Schema path (enables jsonschema validation)") ap.add_argument("--simulate-mac", action="store_true", help="simulate HMAC check with test salt") ap.add_argument("--test-salt", default="DEAD_BEEF_TEST_SALT", help="custom test salt for simulated MAC") ap.add_argument("--verbosity", choices=["quiet","normal","verbose"], default="normal", help="control diagnostic verbosity") ap.add_argument("--strict-mapping", action="store_true", help="fail if FWD/REV parity is missing") ap.add_argument("--show-mapping-gaps", action="store_true", help="always show mapping gaps even at low verbosity") ap.add_argument("--fail-on-warn", action="store_true", help="fail if warnings exceed threshold (see --warn-threshold)") ap.add_argument("--warn-threshold", type=int, help="maximum allowed warnings (after ignoring tags); default 0 when --fail-on-warn set") ap.add_argument("--ignore-warn-tags", default="", help="comma list of tags to ignore for failure (e.g., ORPHAN,MAP)") ap.add_argument("--detector-strict", dest="detector_strict", action="store_true", help="detector exceptions are fatal (default)") ap.add_argument("--no-detector-strict", dest="detector_strict", action="store_false", help="detector exceptions become warnings in audit/dev") ap.add_argument("--skip-detectors", default="", help="comma list of detector labels or rule ids to skip") ap.add_argument("--only-detectors", default="", help="comma list of detector labels or rule ids to run exclusively") ap.set_defaults(detector_strict=True) args = ap.parse_args() global VERBOSITY, STRICT_MAPPING, DETECTOR_STRICT, SHOW_MAPPING_GAPS VERBOSITY = {"quiet":Verb.QUIET,"normal":Verb.NORMAL,"verbose":Verb.VERBOSE}[args.verbosity] STRICT_MAPPING = bool(args.strict_mapping) DETECTOR_STRICT = bool(args.detector_strict) SHOW_MAPPING_GAPS = bool(args.show_mapping_gaps) ignore_tags = set([t.strip() for t in args.ignore_warn_tags.split(",") if t.strip()]) if args.ignore_warn_tags else set() skip_set = set([t.strip() for t in args.skip_detectors.split(",") if t.strip()]) if args.skip_detectors else set() only_set = set([t.strip() for t in args.only_detectors.split(",") if t.strip()]) if args.only_detectors else set() with open(args.path,"r",encoding="utf-8") as f: lock = json.load(f) validate(lock, mode=Mode(args.mode), warn_only=args.warn_only, compat_arg=args.compat, ignore_integrity=args.ignore_integrity, schema_path=args.schema, simulate_mac=args.simulate_mac, test_salt=args.test_salt, fail_on_warn=args.fail_on_warn, warn_threshold=args.warn_threshold, ignore_warn_tags=ignore_tags, skip_detectors=skip_set, only_detectors=only_set) if __name__=="__main__": main()
